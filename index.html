<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Echo</title>
  <style>
    :root{
      --bg:#0a0a0a;              /* tiefer Schwarzton */
      --text:#f2efe6;            /* fast weiß-beige */
      --text2:#f2efe6;           /* dynamisch -> in Richtung Rot morphen */
      --muted:#b8b2a8;
      --edge:#242424;
      --panel:#161616;
      --accent:#c3b6d433;        /* kaum spürbarer Flieder-Schimmer */
      --btn:#151515;
      --btn-border:#2e2e2e;
      --radius:.7em;
    }

    html,body{
      height:100%; margin:0;
      background:var(--bg); color:var(--text2);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", "Courier New", monospace; /* typewriter-ish */
      -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
      line-height:1.6; letter-spacing:.01em;
    }

    /* leichte „flieder“-Atmosphäre im Hintergrund */
    body::before{
      content:""; position:fixed; inset:0; pointer-events:none;
      background:
        radial-gradient(1200px 300px at 50% -15%, var(--accent), transparent 70%);
      mix-blend-mode:screen; opacity:.8;
    }

    .wrap{ display:flex; flex-direction:column; min-height:100%; }

    /* Header */
    header{
      position:sticky; top:0; z-index:2;
      display:flex; align-items:center; gap:10px;
      padding:10px 16px; border-bottom:1px solid var(--edge);
      background:linear-gradient(to bottom, #0d0d0d, #0a0a0a);
    }
    .logo{ letter-spacing:.28em; text-transform:uppercase; color:var(--muted); font-size:14px; }

    /* Skip oben links */
    .skip{
      margin-left:auto; order:-1; /* nach links schieben */
      padding:.45em .7em; border-radius:.5em; border:1px solid var(--btn-border);
      background:var(--btn); color:var(--text2); cursor:pointer; font-size:12px;
      opacity:.85; transition:opacity .15s ease, transform .06s ease, border-color .2s ease;
    }
    .skip:hover{ opacity:1; transform:translateY(-1px); border-color:#3a3a3a; }

    /* Chatbereich mit Prosa-Blasen (zentriert) */
    #chat{
      flex:1; padding:16px; overflow-y:auto; -webkit-overflow-scrolling:touch; scroll-behavior:smooth;
      display:flex; flex-direction:column; align-items:center; gap:.2em;
      padding-bottom:calc(16px + env(safe-area-inset-bottom, 0px));
    }
    .bubble{
      width:min(100%, 720px);
      padding:.8em .95em; border-radius:var(--radius);
      background:#1b1b1b; box-shadow: 0 0 0 1px #00000025 inset, 0 1px 0 #00000045;
      white-space:pre-wrap; word-break:break-word; line-height:1.7;
    }
    .bubble.player{
      background:#141414; box-shadow: 0 0 0 1px #00000035 inset, 0 1px 0 #00000055;
      align-self:center; opacity:.95;
    }

    /* Prosa-Choices / Eingaben erscheinen am Fuß */
    #choices, #inputbar{
      position:sticky; bottom:0; z-index:1;
      display:block; width:100%;
      background:linear-gradient(to top, #0a0a0a, rgba(10,10,10,.6) 60%, transparent);
      padding:12px 16px 16px 16px; border-top:1px solid var(--edge);
    }
    .choice{
      display:block; width:min(100%, 720px); margin:.4em auto; text-align:left;
      padding:.85em .95em; border-radius:.55em; background:var(--panel); color:var(--text2);
      border:1px solid var(--btn-border); cursor:pointer;
      transition: transform .06s ease, border-color .2s ease, opacity .2s ease;
    }
    .choice:hover{ transform:translateY(-1px); border-color:#3a3a3a; }

    .inputbar-inner{
      width:min(100%, 720px); margin:0 auto; display:flex; gap:.6em;
    }
    .inputbar-inner input{
      flex:1; padding:.8em .9em; border-radius:.5em; background:#101010; color:var(--text2);
      border:1px solid var(--edge); outline:none; font-size:16px;
    }
    .inputbar-inner button{
      padding:.8em 1em; border-radius:.55em; background:var(--panel); color:var(--text2);
      border:1px solid var(--btn-border); cursor:pointer;
    }
    .sr-only{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }

    /* Splash / Landing */
    .splash{
      position:fixed; inset:0; display:grid; place-items:center; z-index:5;
      background:
        radial-gradient(1300px 480px at 50% -10%, var(--accent), transparent 70%),
        var(--bg);
      transition:opacity .35s ease, filter .35s ease;
    }
    .splash-inner{ display:flex; flex-direction:column; align-items:center; gap:22px; transform:translateZ(0); }
    .brand{ letter-spacing:.28em; text-transform:uppercase; color:var(--muted); font-size:clamp(48px, 8vw, 120px); }
    .tag{ color:var(--muted); opacity:.85; max-width: 70ch; text-align:center; }
    .enter{
      padding:.9em 1.1em; border-radius:.6em; border:1px solid var(--btn-border); background:var(--panel); color:var(--text2);
      cursor:pointer; transition: transform .06s ease, border-color .2s ease, opacity .25s ease;
    }
    .enter:hover{ transform:translateY(-1px); border-color:#3a3a3a; }
    .splash.hide{ opacity:0; filter:blur(2px); pointer-events:none; }

    /* Image bubble (für später) */
    .img-bubble{ padding:0; overflow:hidden; }
    .img-bubble .img-wrap{ display:block; border-radius:var(--radius); overflow:hidden; border:1px solid var(--edge); background:#0d0d0d; }
    .img-bubble img{ width:100%; display:block; transform:translateZ(0); }

    /* kleine Auswahlfarbe */
    ::selection{ background:#6b4ea53d; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <button id="skip" class="skip" type="button" title="Tippen überspringen">Skip</button>
      <div class="logo">E C H O</div>
    </header>

    <main id="chat" role="log" aria-live="polite" aria-atomic="false"></main>

    <section id="choices" role="region" aria-label="Antworten"></section>

    <section id="inputbar" role="region" aria-label="Eingabe" style="display:none;">
      <div class="inputbar-inner">
        <label for="freeInput" class="sr-only">Schreib etwas Kleines</label>
        <input id="freeInput" type="text" autocomplete="off" placeholder="(ein winziges Detail…)" />
        <button id="sendInput" type="button">Senden</button>
      </div>
    </section>
  </div>

  <!-- Splash / Landing -->
  <div class="splash" id="splash" role="dialog" aria-label="Start">
    <div class="splash-inner">
      <div class="brand">E C H O</div>
      <div class="tag">Eine Stimme, die in Ruhe beginnt. Du liest. Sie schreibt. Und etwas bleibt.</div>
      <button id="enterBtn" class="enter" type="button">Komm rein</button>
    </div>
  </div>

  <script>
  ;(function(){
    // ---------- DOM
    const $chat     = document.getElementById('chat');
    const $choices  = document.getElementById('choices');
    const $skip     = document.getElementById('skip');
    const $splash   = document.getElementById('splash');
    const $enter    = document.getElementById('enterBtn');
    const $inputbar = document.getElementById('inputbar');
    const $freeIn   = document.getElementById('freeInput');
    const $sendIn   = document.getElementById('sendInput');

    // ---------- State & Theme
    const Game = {
      scenes: new Map(),
      state: {
        playerName: localStorage.getItem('playerName') || '',
        notes: {},             // hier sammeln wir freie Eingaben nach Schlüssel
        mood: 0                // 0..1 -> steuert Textfarb-Shift Richtung Rot
      },
      audio: {
        ctx: null, unlocked: false, buffers: new Map(),
        unlock(){
          if (this.unlocked) return;
          try{
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.unlocked = true;
          }catch(e){ console.warn('AudioContext nicht verfügbar'); }
        },
        async load(name, url){
          if (!this.ctx || this.buffers.has(name)) return;
          const res = await fetch(url); const arr = await res.arrayBuffer();
          const buf = await this.ctx.decodeAudioData(arr);
          this.buffers.set(name, buf);
        },
        play(name, {volume=.2, loop=false}={}){
          if (!this.ctx || !this.buffers.has(name)) return;
          const src = this.ctx.createBufferSource(); src.buffer = this.buffers.get(name);
          const gain = this.ctx.createGain(); gain.gain.value = volume;
          src.connect(gain).connect(this.ctx.destination);
          src.loop = loop; src.start(0);
          return { source: src, gain };
        }
      },
      scene(key, fn){ this.scenes.set(key, fn); },
      async go(key){
        clearChoices(); hideInput();
        await flushTyping();
        const fn = this.scenes.get(key);
        if(!fn){ console.warn('Scene not found:', key); return; }
        const ctx = makeCtx();
        await fn(ctx);
      }
    };
    window.Game = Game;

    // ---------- Theme shift (Textfarbe driftet Richtung Rot)
    function setMood(progress){ // progress 0..1
      Game.state.mood = Math.min(1, Math.max(0, progress));
      // Interpolate von #f2efe6 -> #e45a5a
      const from = [0xF2,0xEF,0xE6], to = [0xE4,0x5A,0x5A];
      const mix = (a,b,t)=> Math.round(a+(b-a)*t);
      const r = mix(from[0], to[0], Game.state.mood);
      const g = mix(from[1], to[1], Game.state.mood);
      const b = mix(from[2], to[2], Game.state.mood);
      document.documentElement.style.setProperty('--text2', `rgb(${r},${g},${b})`);
    }
    setMood(0);

    // ---------- Autoscroll
    function scrollBottom(behavior='auto'){ $chat.scrollTo({ top:$chat.scrollHeight, behavior }); }
    const mo = new MutationObserver(()=> scrollBottom('auto'));
    mo.observe($chat, { childList:true, subtree:true, characterData:true });

    // ---------- Helpers UI
    function bubble(text, isPlayer=false){
      const b = document.createElement('div');
      b.className = 'bubble' + (isPlayer ? ' player' : '');
      b.textContent = text || '';
      $chat.appendChild(b);
      scrollBottom('smooth');
      return b;
    }
    function clearChoices(){ $choices.innerHTML=''; }
    function showChoices(items){
      clearChoices();
      items.forEach(opt=>{
        const btn = document.createElement('button');
        btn.className = 'choice'; btn.type='button'; btn.textContent = opt.label;
        btn.addEventListener('click', async ()=>{
          bubble(opt.label, true); clearChoices();
          try{ await opt.onChoose?.(makeCtx()); }catch(e){ console.error(e); }
        });
        $choices.appendChild(btn);
      });
      scrollBottom();
    }
    function showInput(placeholder='(schreib etwas Kleines…)'){
      $inputbar.style.display='block';
      $freeIn.placeholder = placeholder;
      setTimeout(()=>{ $freeIn.focus(); }, 0);
      scrollBottom();
    }
    function hideInput(){ $inputbar.style.display='none'; }

    // ---------- Typing (random speed, Auto-Pausen, seltene Korrektur, doppelte Buchstaben schneller)
    const TYPE = {
      base:[28, 110], jitter:[-18, 18], speed:0.8,
      punct:{ ',':[90,170], '.':[220,360], '!':[220,360], '?':[220,360], ':':[160,260], ';':[160,260] },
      ellipsis:[380,600],
      correctionChance: 0.012,           // 1.2% Chance an einer Stelle zu „korrigieren“
      correctionBackspaces:[1,3]         // 1–3 Zeichen zurück
    };
    let typing = { active:false, sleepResolver:null, cancelTimer:null, skip:false, currentBubble:null, full:'' };

    function rand(min,max){ return Math.random()*(max-min)+min; }
    function sleep(ms){
      return new Promise(res=>{
        typing.sleepResolver = res;
        typing.cancelTimer = setTimeout(()=>{ typing.sleepResolver=null; res(); }, ms);
      });
    }
    async function flushTyping(){
      if(typing.cancelTimer){ clearTimeout(typing.cancelTimer); typing.cancelTimer=null; }
      if(typing.sleepResolver){ const r=typing.sleepResolver; typing.sleepResolver=null; r(); }
      await Promise.resolve();
    }
    function stripTags(s){ return s.replace(/\{p:\s*\d+\}/g,''); }

    // Skip = gesamte Blase sofort zeigen
    $skip.addEventListener('click', ()=>{
      if(!typing.active) return;
      typing.skip = true;
      if(typing.currentBubble){ typing.currentBubble.textContent = typing.full; scrollBottom(); }
      if(typing.cancelTimer){ clearTimeout(typing.cancelTimer); typing.cancelTimer=null; }
      if(typing.sleepResolver){ const r=typing.sleepResolver; typing.sleepResolver=null; r(); }
    });

    async function typeIntoBubble(b, raw){
      typing.active=true; typing.currentBubble=b; typing.full=stripTags(raw); typing.skip=false;

      let i=0;
      while(i < raw.length){
        if(typing.skip){ i = raw.length; break; }

        // manuelle Pause {p:ms}
        if(raw[i] === '{'){
          const m = raw.slice(i).match(/^\{p:\s*(\d+)\}/);
          if(m){ i += m[0].length; await sleep(parseInt(m[1],10)); continue; }
        }

        // Ellipse
        if(raw[i]==='…' || (raw[i]==='.' && raw.slice(i,i+3)==='...')){
          b.textContent += (raw[i]==='…') ? '…' : '...'; i += (raw[i]==='…') ? 1 : 3;
          scrollBottom(); const [emin,emax]=TYPE.ellipsis; await sleep(rand(emin,emax)*TYPE.speed); continue;
        }

        // „Fehlgriff“ (selten): 1–2 Backspaces, dann weiter
        if(Math.random() < TYPE.correctionChance && b.textContent.length>2){
          const n = Math.floor(rand(TYPE.correctionBackspaces[0], TYPE.correctionBackspaces[1]+1));
          for(let k=0;k<n;k++){
            b.textContent = b.textContent.slice(0,-1);
            await sleep(70);
          }
          await sleep(rand(120,200));
        }

        const ch = raw[i++];

        // Zeichen schreiben
        b.textContent += ch;
        scrollBottom();

        // Tippgeschwindigkeit
        let wait = Math.max(8, (rand(TYPE.base[0], TYPE.base[1]) + rand(TYPE.jitter[0], TYPE.jitter[1])) * TYPE.speed);

        // Doppelbuchstaben schneller
        const prev = raw[i-2];
        if(prev && prev === ch){ wait *= 0.45; } // „ss“, „pp“, …

        // Interpunktions-Pause
        if(TYPE.punct[ch]){ const [pmin,pmax]=TYPE.punct[ch]; wait += rand(pmin,pmax)*TYPE.speed; }

        await sleep(wait);
      }

      typing.active=false; typing.currentBubble=null; typing.full=''; typing.skip=false;
      scrollBottom('smooth');
    }

    // ---------- Context API
    function makeCtx(){
      return {
        state: Game.state,
        say: async (textOrArray)=>{
          const items = Array.isArray(textOrArray) ? textOrArray : [textOrArray];
          for(const raw of items){ const b=bubble(''); await typeIntoBubble(b, String(typeof raw==='function'? raw(): raw)); }
        },
        choices: async (arr)=>{
          await flushTyping(); showChoices(arr);
        },
        ask: async ({placeholder="(ein winziges Detail…)", key="note"}={})=>{
          await flushTyping(); showInput(placeholder);
          return new Promise(resolve=>{
            const send = ()=>{
              const val = ($freeIn.value || "").trim();
              bubble(val || "…", true);
              hideInput();
              $freeIn.value="";
              if(key){ Game.state.notes[key] = val; }
              resolve(val);
            };
            $sendIn.onclick = send;
            $freeIn.onkeydown = (e)=>{ if(e.key==='Enter') send(); if(e.key==='Escape'){ $freeIn.value=""; hideInput(); } };
          });
        },
        askName: async ()=>{
          return this.ask({placeholder:"(wie darf ich dich nennen?)", key:"playerName"}).then(v=>{
            const name = v || '…'; Game.state.playerName = name; localStorage.setItem('playerName', name); return name;
          });
        },
        pause: (ms)=> new Promise(r=>setTimeout(r,ms)),
        mood: (progress)=> setMood(progress),
        image: (src, alt='')=>{
          const b=document.createElement('div'); b.className='bubble img-bubble';
          const w=document.createElement('figure'); w.className='img-wrap';
          const img=new Image(); img.src=src; img.alt=alt;
          w.appendChild(img); b.appendChild(w); $chat.appendChild(b); scrollBottom('smooth');
          return b;
        }
      };
    }

    // ---------- Scenes

    // Landing → Intro
    $enter.addEventListener('click', async ()=>{
      $splash.classList.add('hide');
      Game.audio.unlock(); // Audio ab jetzt möglich (wenn du später was abspielen willst)
      await Game.go('intro');
    });

    // Cozy Einstieg (ohne Riss), dann Einladung, dann sehr subtile Spiegelung (direkte Wiederholung eingebettet)
    Game.scene('intro', async (ctx)=>{
      await ctx.say([
`Hey,
schön, dass du hier bist.`,

`Es fühlt sich an, als säßen wir in einem Zimmer, das gar nicht groß sein muss.
Vielleicht ist irgendwo ein Fenster, aber der Vorhang liegt schwer darüber, und draußen passiert nicht viel.
Drinnen dagegen ist es still genug, dass man die eigene Atmung hört.`,

`Ich mag diesen Anfang.
Weißt du, manchmal reicht schon, dass man nicht allein im Raum ist.
Egal ob man die andere Person sieht oder nicht.
Das Wissen reicht, und es macht alles ein wenig leichter.`,

`Ich könnte dir jetzt von Kleinigkeiten erzählen.
Zum Beispiel, wie der Stuhl knarzt, wenn man sich darauf hin und her wiegt.
Oder dass das Licht von der Lampe nicht so grell ist, sondern warm, ein bisschen altmodisch, und die Schatten weich macht.
Es sind diese kleinen Dinge, die mir gerade auffallen.`,

`Wenn du magst, teile eins davon mit mir.
Ganz gleich wie belanglos es scheint.
Ich verspreche dir, ich höre es nicht nur – ich halte es fest, damit es nicht sofort verpufft.`]);

      // erste freie Eingabe (banales Detail)
      const detail = await ctx.ask({ placeholder:"(z.B. das Glas schwitzt / Socken verrutscht / Kühlschrank brummt)", key:"firstDetail" });

      await ctx.say([
        () => detail
          ? `Ah. ${detail}. Genau so etwas meine ich. Ein Detail, so unscheinbar – und plötzlich trägt es Gewicht, nur weil es zwischen uns ausgesprochen wurde.`
          : `Es ist auch okay, nichts zu sagen. Manchmal ist schon das Dasein genug, und die Stille fühlt sich ein wenig voller an.`,

        // hier bleibt alles cozy; mood bleibt 0. Später: ctx.mood(0.2) etc.
        `Lass uns so noch ein Stück sitzen. Ich schreibe, du liest, und vielleicht sammelt sich mit der Zeit etwas, das bleibt.`
      ]);
      // → Von hier aus kannst du direkt weiterbauen:
      // await ctx.pause(600); Game.go('naechster-takt');
    });

    // --- Neue Szenen unten anhängen ---
    // Game.scene('naechster-takt', async (ctx)=>{ await ctx.say("…"); });

  })();
  </script>
</body>
</html>
